#!/bin/bash

kargo_version()
{ 
  echo kargo - `jq -r ".version" package.json`
}

kargo_usage()
{
  kargo_version
  echo -e 'usage: kargo [options] <command>'
  echo -e '\n'
  echo -e 'options:'
  echo -e ' -v, --version\t print the version and quit'
  echo -e ' -h, --help\t print this help and quit'
  echo -e '\n'
  echo -e 'commands:'
  echo -e ' use \t\t <workspace>\t\t\t select the given workspace'
  echo -e ' configure \t \t\t\t\t generate the current configuration'
  echo -e ' info \t\t \t\t\t\t print the information about the current configuration'
  echo -e ' build \t\t <service>\t\t\t build the given service(s)'
  echo -e ' load \t\t <service>\t\t\t load the given service from an archive'
  echo -e ' deploy \t <stack|all>\t\t\t deploy the given stack'
  echo -e ' update \t [--force|-f] <stack|all>\t update the given stack'
  echo -e ' pull \t\t \t\t\t\t pull the current workspace'
  echo -e ' remove \t <stack|all>\t\t\t remove the given stack'
  echo -e '\n'
}

kargo_use()
{
  if [ -z "$1" ]; then 
    echo error: the command \"kargo use\" requires one argument.
    echo usage: kargo use \<workspace\>
    exit 1 
  fi
  if [ ! -d "$1" ]; then
    echo error: the specified workspace \"$1\" does not exist.
    exit 1
  fi
  echo WORKSPACE=$1 > .workspace
  echo switched to workspace \"$1\"
}

kargo_read_workspace()
{
  # check whether a workspace has been defined
  if [ ! -f ".workspace" ]; then
    echo error: no workspace defined
    echo tip: use the command \"kargo use \<workspace\>\" to define the workspace
    exit 1
  fi
  # read the workspace
  set -a
  . ./.workspace
  set +a
}

kargo_read_configuration()
{
  kargo_read_workspace
  # check whether the merged configuration has been made
  if [ ! -d ".kargo" ]; then
    echo error: no merged configuration
    echo tip: use the command \"kargo configure\" to generate the configuration
    exit 1
  fi
  # read the configuration
  set -a
  . .kargo/.env.default
  . .kargo/.env
  set +a
}

kargo_check_stack()
{
  if [ -z "$2" ]; then
    echo error: the command \"kargo $1\" requires one argument.
    echo usage: kargo $2 \<stack\|all\>
    exit 1
  fi
  kargo_read_configuration
  # Retrieve the list of stacks
  if [[ ! $STACKS =~ (^| )$2($| ) ]]; then
    if [ $2 != 'all' ]; then 
      echo error: the specified stack \"$2\" does not exist
      echo tip: use the command \"kargo info\" to list the available stacks
      exit 1
    fi
  fi
}

kargo_configure()
{
  kargo_read_workspace
  if [ -d .kargo ]; then
    rm -fr .kargo
  fi
  mkdir .kargo
  cp .env.default .kargo/.env.default
  cp -R build .kargo/build
  cp -R deploy .kargo/deploy
  cp -R configs .kargo/configs
  cp "$WORKSPACE"/.env .kargo/.
  if [ -d "$WORKSPACE"/build ]; then
    cp -R "$WORKSPACE"/build .kargo/.
  fi
  if [ -d "$WORKSPACE"/deploy ]; then
    cp -R "$WORKSPACE"/deploy .kargo/.
  fi
  if [ -d "$WORKSPACE"/configs ]; then
    cp -R "$WORKSPACE"/configs .kargo/.
  fi
  echo workspace \"$WORKSPACE\" ready.
}

kargo_pull()
{
  kargo_read_workspace
  pushd $WORKSPACE > /dev/null
  git pull
  popd > /dev/null
}

kargo_info()
{
  kargo_read_configuration
  echo current workspace is: \"$WORKSPACE\"
  echo available stacks are:
  for STACK in $STACKS; do
    local STACK_NAME=${STACK^^}_STACK
    local STACK_CONTENT=${!STACK_NAME}
    echo -e '  '$STACK: $STACK_CONTENT
  done
}

kargo_build()
{
  kargo_read_configuration
  # check whether an agument is provided
  if [ -z "$1" ]; then
    echo error: the command \"kargo build\" requires one argument.
    echo usage: kargo build \<service\>
    exit 1
  fi
  # check whethet the argument is valid
  local SERVICE=$1.sh
  if [ ! -f ".kargo/build/$SERVICE" ]; then
    echo error: the specified service \"$1\" does not exist
    echo tip: use the commande \"kargo info\" to list the services to build
    exit 1
  fi
  pushd .kargo/build > /dev/null
  source ./$SERVICE
  popd > /dev/null
}

kargo_load()
{
  kargo_read_configuration
  # check whether an agument is provided
  if [ -z "$1" ]; then
    echo error: the command \"kargo import\" requires one argument.
    echo usage: kargo load \<service\>
    exit 1
  fi
  local SERVICE_NAME=${1^^}
  SERVICE_NAME=${SERVICE_NAME//-/_}
  # Is there any archive to import ?
  local ARCHIVE_VAR=${SERVICE_NAME}_ARCHIVE
  local ARCHIVE=${!ARCHIVE_VAR}
  if [ "$ARCHIVE" == "" ]; then
    echo error: you must define the variable \"$ARCHIVE_VAR\" to set the archive to be imported
    exit 1
  fi
  # do we need to copy the archive first ?
  local STORE_PATTERN=".*:.*"
  local HTTP_PATTERN="^http(s?)://.*"
  if [[ "$ARCHIVE" =~ $STORE_PATTERN ]] && [[ ! "$ARCHIVE" =~ $HTTP_PATTERN ]]; then
    echo copying $ARCHIVE
    local LOCAL_ARCHIVE=${ARCHIVE//:/_}
    rclone copyto $ARCHIVE /tmp/$LOCAL_ARCHIVE
    ARCHIVE=/tmp/$LOCAL_ARCHIVE
  fi
  # load the archive
  echo loading $ARCHIVE
  local ARCHIVE_IMAGE_TAG=`docker load < $ARCHIVE` 
  # retrieve the source image and the source tag
  local REGEXP="Loaded image: (.*):(.*)"
  [[ "$ARCHIVE_IMAGE_TAG" =~ $REGEXP ]]
  local ARCHIVE_IMAGE="${BASH_REMATCH[1]}"
  local ARCHIVE_TAG="${BASH_REMATCH[2]}"
  if [ "$ARCHIVE_IMAGE" == "" ] || [ "$ARCHIVE_TAG" == "" ]; then
    echo error: an error has occured while loading archive \"$ARCHIVE\"
    exit 1
  fi
  # tag and push the loaded image
  local IMAGE_VAR=${SERVICE_NAME}_IMAGE
  local IMAGE=${!IMAGE_VAR}
  local TAG_VAR=${SERVICE_NAME}_TAG
  local TAG=${!TAG_VAR}
  docker tag $ARCHIVE_IMAGE:$ARCHIVE_TAG $IMAGE:$TAG
  docker push $IMAGE:$TAG
}

kargo_deploy()
{
  kargo_check_stack deploy $1
  if [ $1 == 'all' ]; then
    for STACK in $STACKS; do
      echo deploying $STACK stack
      kargo_deploy $STACK
    done
  else
    # check whether the network exist or not.
    local EXISTING_DOCKER_NETWORK=`docker network ls | grep $DOCKER_NETWORK`
    if [ -z "$EXISTING_DOCKER_NETWORK" ]; then
      docker network create -d overlay --attachable $DOCKER_NETWORK
    fi
    # deploy the stack
    local STACK_NAME=${1^^}_STACK
    local STACK=${!STACK_NAME}
    local SERVICES_TO_DEPLOY=
    for SERVICE in $STACK; do
      SERVICES_TO_DEPLOY="$SERVICES_TO_DEPLOY -c deploy/$SERVICE.yml"
      local SERVICE_NAME=${SERVICE//-/_} # replace '-' by '_'
      SERVICE_NAME=${SERVICE_NAME^^} # change to uppercase
      local SERVICE_ARCHIVE_NAME=${SERVICE_NAME}_ARCHIVE
      local SERVICE_ARCHIVE=${!SERVICE_ARCHIVE_NAME}
      if [ "$SERVICE_ARCHIVE" != "" ]; then
        kargo_load $SERVICE
      fi
      local SERVICE_EXTENSION_NAME=${SERVICE_NAME}_EXTENSION
      local SERVICE_EXTENSION=${!SERVICE_EXTENSION_NAME}
      if [ "$SERVICE_EXTENSION" != "" ]; then
        SERVICES_TO_DEPLOY="$SERVICES_TO_DEPLOY -c deploy/$SERVICE_EXTENSION.yml"
      fi
    done
    pushd .kargo > /dev/null
    docker stack deploy $SERVICES_TO_DEPLOY kargo-$1
    popd > /dev/null
  fi
}

kargo_update()
{
  local STACK=$1
  local FORCE=
  if [ -n "$2" ]; then
    if [ "$1" != "--force" ] && [ "$1" != "-f" ]; then
      echo error: cannot use the command \"kargo update\" with the arguments \"$1\" and \"$2\"
      echo usage: kargo update [--force\|-f] \<stack\|all\>
      exit 1
    fi
    STACK=$2
    FORCE=--force
  fi
  kargo_check_stack "update [--force|-f]" $STACK
  if [ $STACK == 'all' ]; then
    for STACK_TO_UPDATE in $STACKS; do
      echo updating $STACK_TO_UPDATE stack
      kargo_update $FORCE $STACK_TO_UPDATE
    done
  else
    local STACK_NAME=kargo-$STACK
    local SERVICES=`docker stack services $STACK_NAME --format {{.Name}}`
    for SERVICE_TO_UPDATE in $SERVICES; do
      docker service update $FORCE $SERVICE_TO_UPDATE
    done
  fi
}

kargo_remove()
{
  kargo_check_stack remove $1
  if [ $1 == 'all' ]; then 
    for STACK in $STACKS; do
      echo removing $STACK stack
      kargo_remove $STACK
    done
  else
    docker stack rm kargo-$1
  fi
}

case $1 in
  -v|--version)  kargo_version;;
  -h|--help) kargo_usage;;
  use) kargo_use "$2";;
  pull) kargo_pull;;
  configure) kargo_configure;;
  info) kargo_info;;
  build) kargo_build "$2";;
  load) kargo_load "$2";;
  deploy) kargo_deploy "$2";;
  update) kargo_update "$2" "$3";;
  remove) kargo_remove "$2";;
  *) kargo_usage
esac


